using LinearAlgebra
using Combinatorics
using Printf

setprecision(128)



function RenumberPermutations(sigma,tau)
    #apply a permutation to sigma and tau such that sigma becomes (1,...,n)

    lengthcycle = length(sigma);
    SigmaDict = Dict()
    for i=1:lengthcycle 
        SigmaDict[sigma[i]] = i
    end
 
    outputsigma = Array((1:lengthcycle));
    outputtau = Array((1:lengthcycle));
    for i=1:lengthcycle
        outputtau[i] = SigmaDict[tau[i]]
    end
    #note that 1 is always mapped to 1 in this way (as sigma starts with 1), 
    #so no adjustments needed at the end to let the outputcycles start with 1.

    return (outputsigma, outputtau)
end


#println(RenumberPermutations([1,3,4,5,2],[1,2,3,4,5]))


function EquivalenceClasses(n,Reduced=true)
    Vertices = collect(permutations(Array((2:n))))
    for vertex in Vertices
        pushfirst!(vertex, 1)
    end

    Numbers = Dict{Array{Int8,1},UInt32}();
    number=1;

    function Process(vertex)
        Numbers[vertex]=number;
        # We apply the subgroup of G which fixes sigma = (1,2,3,...,n)
        # this subgroup is generated by two permutations
        # 1. the permutation sigma itself 
        # 2. the element which does: invert sigma and then apply the permutation which maps n->2, n-1 ->3, ....,2->n

        # We apply the permutation sigma 
        EersteElement = deepcopy(vertex)
        for i=1:n 
            EersteElement[i] = vertex[i]+1 <=n ? vertex[i]+1 : 1; 
        end
        indexwith1 = findfirst(x-> x==1,EersteElement)
        EersteElement = vcat(EersteElement[indexwith1:end],EersteElement[1:(indexwith1-1)])
        if !haskey(Numbers,EersteElement)
            Process(EersteElement);
        end


        # We apply the element which does: invert sigma and then apply the permutation which maps n->2, n-1 ->3, ....,2->n
        TweedeElementTemp = deepcopy(vertex); 
        TweedeElementTemp[2:end]=TweedeElementTemp[end:-1:2]; 

        TweedeElement = deepcopy(TweedeElementTemp);
        for i=2:n 
            imappedto = n-(i-2); 
            indexwithi = findfirst(x-> x==i,TweedeElementTemp)
            TweedeElement[indexwithi]=imappedto 
        end
        if !haskey(Numbers,TweedeElement)
            Process(TweedeElement);
        end

        if Reduced
            (swapsigma, swaptau) = RenumberPermutations(vertex,Array((1:n)))
            if !haskey(Numbers,swaptau)
                Process(swaptau)
            end
        end

    end


    for vertex in Vertices
        if !haskey(Numbers, vertex)
            Numbers[vertex]=number;
            Process(vertex);
            number+=1;
            # if mod(number,1000)==0
            #     println(number)
            # end
        end    
    end

    number-=1;
    return Numbers, number; 
end


# @time EquivalenceClasses(7,true)
# @time EquivalenceClasses(8,true)
# @time EquivalenceClasses(9,true)
# @time EquivalenceClasses(10,true)
 @time Numbers,number = EquivalenceClasses(10,true)
 println(number)

# @time EquivalenceClasses(12,true)








### Help function to compute character
### permutation is entered as a vector with on the i-th position the number f(i)
### epsilon =1 or -1, which corresponds to inverting or not inverting. 
function NumberOfFixedPoints(n,permutation, epsilon)
    ## First create all n-cycles, ie. all elements in Z_n
    Vertices = collect(permutations(Array((2:n))))
    for vertex in Vertices
        pushfirst!(vertex, 1)
    end

    noFixed =0; 
    for vertex in Vertices
        HelpVertex = deepcopy(vertex); 
        if epsilon ==-1
            HelpVertex[2:end]=HelpVertex[end:-1:2]; 
        end
        for i=1:n 
            HelpVertex[i]=permutation[HelpVertex[i]];
        end
        ##renumber so it starts with 1
        indexwith1 = findfirst(x-> x==1,HelpVertex)
        HelpVertex = vcat(HelpVertex[indexwith1:end],HelpVertex[1:(indexwith1-1)])

        if vertex == HelpVertex
            noFixed+=1;
        end
    end
    #println(noFixed)
    return noFixed
end

function NumberOfFixedPoints2(n,permutation, epsilon)
    ## First create all n-cycles, ie. all elements in Z_n
    Vertices = collect(permutations(Array((2:n))))
    for vertex in Vertices
        pushfirst!(vertex, 1)
    end

    noFixed =0; 
    for vertex in Vertices
        HelpVertex = deepcopy(vertex); 
        if epsilon ==-1
            HelpVertex[2:end]=HelpVertex[end:-1:2]; 
        end
        # for i=1:n 
        #     # HelpVertex[i]=permutation[HelpVertex[i]];
            
        #     HelpVertex[i]=HelpVertex[permutation];
        # end
        HelpVertex = HelpVertex[permutation]
        ##renumber so it starts with 1
        # indexwith1 = findfirst(x-> x==1,HelpVertex)
        # HelpVertex = vcat(HelpVertex[indexwith1:end],HelpVertex[1:(indexwith1-1)])

        HelpVertex .+= 0-HelpVertex[1] + n
        HelpVertex .%= n
        HelpVertex .+= 1

        if vertex == HelpVertex
            noFixed+=1;
        end
    end
    #println(noFixed)
    return noFixed
end

##

# m = 5
# for p in SymmetricGroup(m)
#     if NumberOfFixedPoints(m, p.d, 1) != NumberOfFixedPoints2(m, p.d, 1)
#         @error("Different")
#         @show p
#         @show (NumberOfFixedPoints(m, p.d, 1), NumberOfFixedPoints2(m, p.d, 1))
#     end
# end

#NumberOfFixedPoints(6,[2,3,4,5,1,6],1)

##
# summi=0;
# n=7
# Symmetries = collect(permutations(Array((1:n))))
# for permutation in Symmetries
#     temp = NumberOfFixedPoints(n,permutation,1)
#     global summi += temp^2;
# end
# println(summi/(factorial(n)));